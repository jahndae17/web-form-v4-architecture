<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToolsContainer Demo - Reactive Drawing Application</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Main Application Container */
        .app-container {
            width: 95vw;
            height: 90vh;
            background: #1a1a1a;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Tools Container Styles */
        .tools-container {
            background: #2d2d2d;
            border-right: 2px solid #444;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            user-select: none;
            overflow: hidden; /* Prevent content overflow when collapsed */
        }

        .tools-container.panel-open {
            width: 200px;
        }

        .tools-container.panel-collapsed {
            width: 0px;
            overflow: hidden;
        }

        /* Tools Panel Header */
        .tools-header {
            height: 50px;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            border-bottom: 1px solid #444;
        }

        .tools-title {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .panel-collapsed .tools-title {
            opacity: 0;
        }

        /* Tools Grid */
        .tools-grid {
            flex: 1;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            align-content: start;
            overflow-y: auto;
        }

        .panel-collapsed .tools-grid {
            padding: 10px 5px;
            grid-template-columns: 1fr;
        }

        /* Tool Item */
        .tool-item {
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .tool-item:hover {
            background: #4a4a4a;
            border-color: #777;
            /* Transform removed - handled by Graphics Handler */
        }

        .tool-item.selected {
            background: #4a90e2;
            border-color: #5aa3f0;
        }

        .tool-item.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
        }

        .tool-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .tool-name {
            color: #fff;
            font-size: 10px;
            font-weight: 500;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .panel-collapsed .tool-name {
            opacity: 0;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            background: white;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin: 0px;
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: #333;
            color: #fff;
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-size: 12px;
            border-top: 1px solid #444;
        }

        .status-item {
            margin-right: 20px;
        }

        /* Mode Toggle Button */
        .mode-toggle-btn {
            background: #007acc;
            color: #fff;
            border: 1px solid #005a99;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
            margin-right: 0;
        }

        .mode-toggle-btn:hover {
            background: #005a99;
            border-color: #003d66;
            transform: translateY(-1px);
        }

        .mode-toggle-btn:active {
            transform: translateY(0);
        }

        .mode-toggle-btn.preview-mode {
            background: #28a745;
            border-color: #1e7e34;
        }

        .mode-toggle-btn.preview-mode:hover {
            background: #1e7e34;
            border-color: #155724;
        }

        /* Panel Toggle Button */
        .panel-toggle {
            background: #4a4a4a;
            color: #fff;
            border: 2px solid #666;
            border-radius: 6px;
            cursor: pointer;
            z-index: 1000;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .panel-toggle:hover {
            background: #5a5a5a;
            border-color: #888;
            /* Transform removed - handled by Graphics Handler */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .panel-toggle:active {
            /* Transform removed - handled by Graphics Handler */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Tool selection animations now handled by Graphics Handler */
        /* @keyframes toolSelect removed - Graphics Handler manages animations */

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
            }
            
            .tools-container.panel-open {
                width: 150px;
            }
            
            .tools-container.panel-collapsed {
                width: 0px;
                overflow: hidden;
            }
            
            .tools-grid {
                gap: 8px;
                padding: 10px;
            }
        }

        /* Scrollbar Styling */
        .tools-grid::-webkit-scrollbar {
            width: 6px;
        }

        .tools-grid::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .tools-grid::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .tools-grid::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Tools Container -->
        <div id="tools-container" class="tools-container panel-open">
            <div class="tools-header">
                <div class="tools-title">Drawing Tools</div>
            </div>
            <div class="tools-grid" id="tools-grid">
                <!-- Tools will be dynamically added here -->
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area" id="canvas-area" data-drop-zone="true" data-drop-zone-type="canvas">
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item" id="current-tool">Tool: None</div>
            <div class="status-item" id="tool-count">Tools: 0</div>
            <div class="status-item" id="panel-status">Panel: Open</div>
            <div class="status-item" id="app-mode">App Mode: Design</div>
            <button class="status-item mode-toggle-btn" id="mode-toggle" title="Toggle between Design and Preview modes">
                🎨 Switch to Preview
            </button>
        </div>
    </div>

    <!-- Load ToolsContainer Implementation -->
    <script src="../Handler/Event Handler.js"></script>
    <script src="../Handler/Graphics Handler.js"></script>
    <script src="../Handler/Errors/SuddenPositionChangeDetector.js"></script>
    <script src="../Handler/Errors/SlingShotErrorDetector.js"></script>
    <script src="../Components/Developer Level/base container.js"></script>
    <script src="../Components/Developer Level/FormBuilderCanvas.js"></script>
    <script src="../Components/Developer Level/DragAndDropBehavior.js"></script>
    <script src="../Components/Developer Level/tools container.js"></script>
    <script src="../Components/Developer Level/ToolPanelToggleBehavior.js"></script>
    <script src="../Components/User Level/Base User Container/BaseUserContainer.js"></script>
    <script src="../Components/User Level/Base User Container/ResizeableBehavior.js"></script>
    <script src="../Components/User Level/Base User Container/SelectableBehavior.js"></script>
    <script src="../Components/User Level/Base User Container/MovableBehavior.js"></script>
    <script src="../Components/User Level/Base User Container/BaseUserContainerBehavior.js"></script>
    <script src="../Components/User Level/Base User Container/BaseUserContainerFactory.js"></script>
    
    <!-- Native Sign In Component -->
    <script src="../Components/User Level/Login/Native Sign In.js"></script>
    <script src="../Components/User Level/Login/NativeSignInBehavior.js"></script>
    <script src="../Components/User Level/Login/NativeSignInFactory.js"></script>
    
    <!-- Authentication Providers -->
    <script src="../Components/User Level/Login/Amazon Login.js"></script>
    <script src="../Components/User Level/Login/Apple Login.js"></script>
    <script src="../Components/User Level/Login/Azure Login.js"></script>
    <script src="../Components/User Level/Login/Facebook Login.js"></script>
    <script src="../Components/User Level/Login/Google Login.js"></script>
    
    <script>
        // ========================
        // REACTIVE ARCHITECTURE IMPLEMENTATION
        // Following Component Architecture Guidelines
        // ========================
        
        // Create Mock ChangeLog for system coordination
        class MockChangeLog {
            constructor() {
                this.context = new Map();
                this.subscriptions = new Map();
                this.handlers = new Set();
            }
            
            registerHandler(name) {
                this.handlers.add(name);
                console.log(`📝 ChangeLog: Handler ${name} registered`);
            }
            
            startListening(callback) {
                this.callback = callback;
                console.log('📝 ChangeLog: Started listening');
            }
            
            updateContext(path, value, action = 'update', meta = {}) {
                this.context.set(path, value);
                console.log(`📝 ChangeLog: Updated ${path}`);
                
                // Notify subscribers
                if (this.subscriptions.has(path)) {
                    this.subscriptions.get(path).forEach(callback => {
                        try {
                            callback(value);
                        } catch (error) {
                            console.error('ChangeLog callback error:', error);
                        }
                    });
                }
            }
            
            setValue(path, value) {
                this.updateContext(path, value, 'set');
            }
            
            getValue(path, defaultValue = null) {
                return this.context.get(path) ?? defaultValue;
            }
            
            subscribe(path, callback) {
                if (!this.subscriptions.has(path)) {
                    this.subscriptions.set(path, []);
                }
                this.subscriptions.get(path).push(callback);
                console.log(`📝 ChangeLog: Subscribed to ${path}`);
            }
        }

        // Initialize System Architecture
        class ReactiveToolsApplication {
            constructor() {
                this.systemInitialized = false;
                this.init();
            }

            async init() {
                console.log('🎨 Initializing Reactive Tools Application...');
                
                try {
                    // 1. Create ChangeLog for system coordination
                    this.changeLog = new MockChangeLog();
                    
                    // Initialize global application mode state
                    this.changeLog.setValue('application.mode', 'design');
                    this.changeLog.setValue('application.mode_switching_enabled', true);
                    this.changeLog.setValue('application.available_modes', ['design', 'preview']);
                    console.log('🎛️ Global application mode initialized: design');
                    
                    // 2. Create and initialize Event Handler
                    this.eventHandler = new EventHandler(this.changeLog);
                    console.log('⚡ Event Handler initialized');
                    
                    // 3. Create and initialize Graphics Handler with dependencies
                    this.graphicsHandler = new GraphicsHandler(this.eventHandler, this.changeLog);
                    await this.graphicsHandler.init();
                    console.log('🎨 Graphics Handler initialized');
                    
                    // 4. Initialize Error Detection System
                    this.positionDetector = new SuddenPositionChangeDetector();
                    this.slingshotDetector = new SlingShotErrorDetector(this.positionDetector);
                    
                    // Start error monitoring
                    this.positionDetector.startMonitoring(this.changeLog);
                    this.slingshotDetector.startMonitoring(this.changeLog);
                    console.log('🔍 Error Detection System initialized and monitoring');
                    
                    // 5. Create root application container
                    this.rootContainer = new BaseContainer('app-root', null, 'application');
                    console.log('🏠 Root application container created');
                    
                    // 6. Create ToolsContainer as child of root
                    this.toolsContainer = new ToolsContainer('tools-container', this.rootContainer, {
                        panelPosition: 'left',
                        isPanelOpen: true,
                        toolLayout: 'grid',
                        theme: 'dark',
                        selectionMode: 'single',
                        allowedToolTypes: ['brush', 'text', 'shape', 'selector', 'eraser', 'container', 'drawing', 'form'],
                        toolCategories: ['drawing', 'text', 'shapes', 'selection', 'container', 'form'],
                        dropZones: ['canvas-area']
                    });
                    
                    // 7. Assign DOM element to container and set Event Handler
                    const toolsElement = document.getElementById('tools-container');
                    if (!toolsElement) {
                        throw new Error('Tools container element not found in DOM');
                    }
                    this.toolsContainer.element = toolsElement;
                    this.toolsContainer.eventHandler = this.eventHandler;  // Assign Event Handler
                    this.toolsContainer.graphicsHandler = this.graphicsHandler;  // Assign Graphics Handler
                    console.log('🔧 ToolsContainer created and linked to DOM');

                    // 8. Create FormBuilderCanvas as child of root
                    this.formBuilderCanvas = new FormBuilderCanvas('canvas-area', this.rootContainer, {
                        backgroundColor: '#f8f9fa',
                        borderStyle: '2px dashed #dee2e6',
                        snapToGrid: true,
                        showGrid: true,
                        allowOverlap: false,
                        validDropSources: ['tools-container'],
                        allowedToolTypes: ['container', 'form', 'drawing', 'base-user-container']
                    }, this.changeLog);
                    
                    // Assign DOM element and handlers to canvas
                    const canvasElement = document.getElementById('canvas-area');
                    if (!canvasElement) {
                        throw new Error('Canvas area element not found in DOM');
                    }
                    this.formBuilderCanvas.element = canvasElement;
                    this.formBuilderCanvas.eventHandler = this.eventHandler;
                    this.formBuilderCanvas.graphicsHandler = this.graphicsHandler;
                    
                    // Initialize the canvas
                    const canvasInitResult = await this.formBuilderCanvas.initializeContainer();
                    if (!canvasInitResult.success) {
                        throw new Error(`Failed to initialize FormBuilderCanvas: ${canvasInitResult.error}`);
                    }
                    console.log('📋 FormBuilderCanvas created and initialized');

                    // 7. Create and attach behaviors
                    await this.initializeBehaviors();
                    
                    // 7. Create tools and setup initial state
                    this.createDrawingTools();
                    
                    // 8. Setup reactive listeners
                    this.setupReactiveListeners();
                    
                    // 9. Initial render through proper channels
                    await this.initialRender();
                    
                    this.systemInitialized = true;
                    console.log('� Reactive architecture initialized successfully!');
                    
                } catch (error) {
                    console.error('❌ System initialization failed:', error);
                    throw error;
                }
            }

            async initializeBehaviors() {
                // Create and attach toggle behavior
                this.toggleBehavior = new ToolPanelToggleBehavior();
                
                this.toggleBehavior.attachToContainer(this.toolsContainer, {
                    buttonEnabled: true,
                    buttonSymbols: { open: '☰', closed: '▶' },
                    buttonSize: { width: 30, height: 30 },
                    animationEnabled: true,
                    persistState: false,
                    graphicsHandler: this.graphicsHandler  // Pass Graphics Handler reference
                });
                console.log('🔄 Toggle behavior attached with Graphics Handler integration');

                // Create and attach drag and drop behavior
                this.dragAndDropBehavior = new DragAndDropBehavior();
                
                const dragAttachResult = this.dragAndDropBehavior.attachToBehavior(this.toolsContainer);
                if (dragAttachResult.success) {
                    // Configure the behavior with FormBuilderCanvas as drop target
                    this.dragAndDropBehavior.configureBehavior({
                        enabled: this.toolsContainer.dragEnabled,
                        dragThreshold: 5,
                        dragAxis: 'both',
                        showDragPreview: true,
                        previewOpacity: this.toolsContainer.dragPreview.opacity,
                        validDropZones: ['canvas-area'], // HTML element ID for validation
                        dropTargetContainers: [this.formBuilderCanvas], // Container object for handling
                        returnOnFailedDrop: this.toolsContainer.returnOnFailedDrop,
                        throttleMove: 16
                    });
                    
                    // Pass references for coordination
                    this.toolsContainer.dragAndDropBehavior = this.dragAndDropBehavior;
                    this.formBuilderCanvas.dragAndDropBehavior = this.dragAndDropBehavior;
                    console.log('🎯 DragAndDropBehavior attached and configured with FormBuilderCanvas');
                } else {
                    console.error('❌ Failed to attach DragAndDropBehavior:', dragAttachResult);
                }

                // 8. Set up reactive panel state changes
                this.toggleBehavior.onPanelStateChange = () => {
                    console.log('� Panel state changed, updating through Graphics Handler...');
                    this.requestPanelUpdate();
                };
            }

            createDrawingTools() {
                // Add Base User Container as the primary form building tool
                const containerTool = ToolsContainer.createToolItem('base-user-container', 'User Container', 'container', {
                    icon: '📦', 
                    description: 'Base User Container - Foundation for all form elements'
                });

                // Add the container tool to the toolbar
                this.toolsContainer.addTool(containerTool);
                console.log(`🔧 Added tool: ${containerTool.icon} ${containerTool.name}`);

                // Add Native Sign In authentication component
                const nativeSignInTool = ToolsContainer.createToolItem('native-sign-in', 'Native Sign In', 'form', {
                    icon: '🔐', 
                    description: 'Native Sign In - Multi-provider authentication component with passkey support'
                });

                // Add the Native Sign In tool to the toolbar
                this.toolsContainer.addTool(nativeSignInTool);
                console.log(`🔧 Added tool: ${nativeSignInTool.icon} ${nativeSignInTool.name}`);

                // Note: Tool selection and activation will be handled by Event Handler
                // when user interacts with the tool directly
                
                console.log('🔧 Drawing tools added to toolbar (Base User Container, Native Sign In)');
            }

            setupReactiveListeners() {
                // Listen for tool selection changes through ChangeLog
                this.changeLog.subscribe('tools.selection.changed', (data) => {
                    this.handleToolSelectionChange(data);
                });
                
                // Listen for panel state changes
                this.changeLog.subscribe('panel.state.changed', (data) => {
                    this.handlePanelStateChange(data);
                });
                
                // Listen for graphics operations completion
                this.changeLog.subscribe('current_context_meta.graphics.animations', (data) => {
                    this.handleAnimationComplete(data);
                });
            }

            async initialRender() {
                // Render tools through Graphics Handler coordination
                await this.renderToolsReactive();
                
                // Update status through reactive pattern
                this.updateStatusReactive();
                
                // Set initial panel state through Graphics Handler
                await this.requestPanelUpdate();
            }

            async renderToolsReactive() {
                const toolsGrid = document.getElementById('tools-grid');
                if (!toolsGrid) {
                    console.error('❌ Tools grid element not found');
                    return;
                }
                
                // Clear grid through Graphics Handler
                await this.graphicsHandler.updateComponentStyle({
                    componentId: 'tools-grid',
                    styles: { innerHTML: '' }  // Clear content
                });

                // Create tool elements without direct event listeners
                for (const tool of this.toolsContainer.tools) {
                    const toolElement = this.createToolElementReactive(tool);
                    toolsGrid.appendChild(toolElement);
                }
                
                console.log('🎨 Tools rendered through reactive pattern');
            }

            createToolElementReactive(tool) {
                const toolDiv = document.createElement('div');
                toolDiv.className = 'tool-item';
                toolDiv.dataset.toolId = tool.toolId;
                toolDiv.id = `tool-${tool.toolId}`;  // Ensure unique ID for Graphics Handler
                
                // Add drag attributes for DragAndDropBehavior
                toolDiv.draggable = tool.isDraggable !== false;
                toolDiv.dataset.dragType = 'tool';
                toolDiv.dataset.toolType = tool.type;
                
                // Note: Tool states (selected/active) will be managed by Event Handler
                // and applied through Graphics Handler when needed

                toolDiv.innerHTML = `
                    <div class="tool-icon">${tool.icon}</div>
                    <div class="tool-name">${tool.name}</div>
                `;

                // NO EVENT LISTENERS - Let IO Handler capture inputs
                toolDiv.title = tool.description;

                return toolDiv;
            }

            // Note: Tool selection now handled directly by Event Handler through drag and drop interactions
            // No separate selection methods needed

            async requestPanelUpdate() {
                try {
                    // Request panel state change through Graphics Handler
                    const panelWidth = this.toolsContainer.isPanelOpen ? '200px' : '0px';
                    
                    await this.graphicsHandler.updateComponentStyle({
                        componentId: 'tools-container',
                        styles: { width: panelWidth },
                        options: { batch: false, immediate: false }
                    });
                    
                    // Update CSS classes for additional styling
                    const toolsElement = document.getElementById('tools-container');
                    if (toolsElement) {
                        if (this.toolsContainer.isPanelOpen) {
                            toolsElement.classList.remove('panel-collapsed');
                            toolsElement.classList.add('panel-open');
                        } else {
                            toolsElement.classList.remove('panel-open');
                            toolsElement.classList.add('panel-collapsed');
                        }
                    }
                    
                    this.updateStatusReactive();
                    console.log('🎨 Panel update requested through Graphics Handler');
                } catch (error) {
                    console.error('❌ Panel update failed:', error);
                }
            }

            // Event handlers for reactive architecture
            handleToolSelectionChange(data) {
                console.log('🔄 Tool selection changed:', data.toolId);
                this.updateStatusReactive();
            }

            handlePanelStateChange(data) {
                console.log('🔄 Panel state changed:', data);
                this.updateStatusReactive();
            }

            handleAnimationComplete(data) {
                console.log('🎨 Animation completed:', data);
            }

            updateStatusReactive() {
                // Note: Tool selection state now managed by Event Handler
                // For status display, we'll show first tool or none
                const currentTool = this.toolsContainer.tools.length > 0 ? this.toolsContainer.tools[0] : null;
                const currentMode = this.getCurrentMode();
                
                // Update status through DOM (acceptable for status display)
                const elements = {
                    currentTool: document.getElementById('current-tool'),
                    toolCount: document.getElementById('tool-count'),
                    panelStatus: document.getElementById('panel-status'),
                    appMode: document.getElementById('app-mode'),
                    modeToggle: document.getElementById('mode-toggle')
                };
                
                // Safe updates with error checking
                if (elements.currentTool) {
                    elements.currentTool.textContent = `Tool: ${currentTool ? currentTool.name : 'None'}`;
                }
                if (elements.toolCount) {
                    elements.toolCount.textContent = `Tools: ${this.toolsContainer.tools.length}`;
                }
                if (elements.panelStatus) {
                    elements.panelStatus.textContent = `Panel: ${this.toolsContainer.isPanelOpen ? 'Open' : 'Closed'}`;
                }
                if (elements.appMode) {
                    elements.appMode.textContent = `App Mode: ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)}`;
                }
                if (elements.modeToggle) {
                    const isDesignMode = currentMode === 'design';
                    elements.modeToggle.textContent = isDesignMode ? '🔍 Switch to Preview' : '🎨 Switch to Design';
                    elements.modeToggle.className = `status-item mode-toggle-btn ${isDesignMode ? '' : 'preview-mode'}`;
                }
            }

            // ========================
            // GLOBAL MODE MANAGEMENT
            // ========================

            /**
             * Set global application mode
             * @param {string} newMode - 'design' or 'preview'
             */
            setApplicationMode(newMode) {
                const availableModes = this.changeLog.getValue('application.available_modes', ['design', 'preview']);
                
                if (!availableModes.includes(newMode)) {
                    console.error(`❌ Invalid mode: ${newMode}. Available modes:`, availableModes);
                    return { success: false, error: `Invalid mode: ${newMode}` };
                }

                const oldMode = this.changeLog.getValue('application.mode');
                this.changeLog.setValue('application.mode', newMode);
                
                console.log(`🎛️ Application mode changed: ${oldMode} → ${newMode}`);
                
                // Update status bar to show current mode
                this.updateStatusReactive();
                
                // Trigger global mode change event for all components
                this.eventHandler.triggerGlobal?.('mode-changed', {
                    oldMode,
                    newMode,
                    timestamp: Date.now()
                });

                return {
                    success: true,
                    oldMode,
                    newMode,
                    changeLog: {
                        type: 'application_mode_changed',
                        oldMode,
                        newMode,
                        timestamp: Date.now()
                    }
                };
            }

            /**
             * Get current application mode
             */
            getCurrentMode() {
                return this.changeLog.getValue('application.mode', 'design');
            }

            /**
             * Toggle between design and preview modes
             */
            toggleApplicationMode() {
                const currentMode = this.getCurrentMode();
                const newMode = currentMode === 'design' ? 'preview' : 'design';
                return this.setApplicationMode(newMode);
            }

            /**
             * Check if mode switching is enabled
             */
            isModeSwitchingEnabled() {
                return this.changeLog.getValue('application.mode_switching_enabled', true);
            }

            // Public API for debugging (maintaining compatibility)
            getContainer() { return this.toolsContainer; }
            getState() { return this.toolsContainer?.getState(); }
            // Note: Tool interaction now handled through Event Handler - no direct selectTool method
        }

        // ========================
        // SYSTEM INITIALIZATION
        // ========================

        // Initialize the reactive application when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                window.toolsApp = new ReactiveToolsApplication();
                
                // Add mode toggle button event listener
                setTimeout(() => {
                    const modeToggleBtn = document.getElementById('mode-toggle');
                    if (modeToggleBtn) {
                        modeToggleBtn.addEventListener('click', () => {
                            if (window.toolsApp?.isModeSwitchingEnabled()) {
                                const result = window.toolsApp.toggleApplicationMode();
                                if (result.success) {
                                    console.log(`🎛️ Mode toggled: ${result.oldMode} → ${result.newMode}`);
                                } else {
                                    console.error('❌ Mode toggle failed:', result.error);
                                }
                            } else {
                                console.warn('⚠️ Mode switching is disabled');
                            }
                        });
                        console.log('🎛️ Mode toggle button event listener added');
                    }
                }, 100); // Small delay to ensure DOM is ready
                
            } catch (error) {
                console.error('❌ Failed to initialize application:', error);
            }
        });

        // Debug helpers for console (maintaining compatibility)
        window.debugTools = {
            getContainer: () => window.toolsApp?.getContainer(),
            getState: () => window.toolsApp?.getState(),
            // Note: Tool selection now handled by Event Handler - no direct methods
            getGraphicsHandler: () => window.toolsApp?.graphicsHandler,
            getEventHandler: () => window.toolsApp?.eventHandler,
            getDragAndDropBehavior: () => window.toolsApp?.dragAndDropBehavior,
            
            // Container inspection commands
            inspectContainer: (containerId) => {
                if (!containerId) {
                    console.log('📋 Available containers:');
                    if (window.containerRegistry) {
                        for (const [id, container] of Object.entries(window.containerRegistry)) {
                            console.log(`  - ${id}: ${container.userType} (${container.formRole})`);
                        }
                    } else {
                        console.log('  No containers found in registry');
                    }
                    return 'Use inspectContainer("containerId") to inspect a specific container';
                }
                
                const container = window.containerRegistry?.[containerId];
                if (!container) {
                    console.error(`❌ Container not found: ${containerId}`);
                    return null;
                }
                
                const properties = {
                    // Core Properties
                    containerId: container.containerId,
                    userType: container.userType,
                    formRole: container.formRole,
                    parent: container.parent?.containerId || null,
                    
                    // State Properties
                    isInitialized: container.isInitialized,
                    isSelected: container.isSelected,
                    isHovered: container.isHovered,
                    isDragging: container.isDragging,
                    isResizing: container.isResizing,
                    
                    // Behavior Properties
                    isSelectable: container.isSelectable,
                    isResizeable: container.isResizeable,
                    isMovable: container.isMovable,
                    isNestable: container.isNestable,
                    
                    // Form Properties
                    formValue: container.formValue,
                    formName: container.formName,
                    isRequired: container.isRequired,
                    validationRules: container.validationRules,
                    
                    // Hierarchy
                    depth: container.depth,
                    childrenCount: container.children?.length || 0,
                    children: container.children?.map(child => child.containerId) || [],
                    
                    // Behavior Instances
                    hasBehaviors: {
                        selectable: !!container.selectableBehavior,
                        movable: !!container.movableBehavior,
                        resizeable: !!container.resizeableBehavior
                    },
                    
                    // Current Mode
                    currentMode: container.getCurrentMode?.() || 'unknown',
                    isDesignMode: container.isDesignMode?.() || false,
                    
                    // Element Info
                    hasElement: !!container.element,
                    elementId: container.element?.id || null,
                    elementTagName: container.element?.tagName || null,
                    elementClasses: container.element?.className || null
                };
                
                console.log(`🔍 Container Properties: ${containerId}`);
                console.table(properties);
                
                // Show visual specs if available
                if (container.visualSpecs) {
                    console.log('🎨 Visual Specifications:');
                    console.log(container.visualSpecs);
                }
                
                return properties;
            },
            
            // Get container by clicking on it
            selectContainer: () => {
                console.log('👆 Click on any container to inspect it...');
                const clickHandler = (event) => {
                    const element = event.target.closest('[data-component-type="BaseUserContainer"]');
                    if (element) {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        const containerId = element.id;
                        console.log(`🎯 Selected container: ${containerId}`);
                        debugTools.inspectContainer(containerId);
                        
                        // Remove the click handler after selection
                        document.removeEventListener('click', clickHandler, true);
                        console.log('✅ Container selection mode ended');
                    }
                };
                
                document.addEventListener('click', clickHandler, true);
                return 'Click on any container to inspect it. Use Escape to cancel.';
            },
            
            // List all containers with their current states
            listContainers: () => {
                if (!window.containerRegistry) {
                    console.log('❌ No container registry found');
                    return [];
                }
                
                const containers = [];
                for (const [id, container] of Object.entries(window.containerRegistry)) {
                    containers.push({
                        id: id,
                        type: container.userType,
                        role: container.formRole,
                        selected: container.isSelected,
                        dragging: container.isDragging,
                        resizing: container.isResizing,
                        children: container.children?.length || 0,
                        mode: container.getCurrentMode?.() || 'unknown'
                    });
                }
                
                console.log('📋 All Containers:');
                console.table(containers);
                return containers;
            },
            
            // Lock debugging tools
            checkLocks: () => {
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return null;
                }
                
                const lockStatus = eventHandler.getDetailedLockStatus();
                
                console.log('🔒 Lock System Status:');
                console.log('📊 Summary:', lockStatus.summary);
                
                if (lockStatus.activeLocks.length > 0) {
                    console.log('\n🟢 Active Locks:');
                    console.table(lockStatus.activeLocks);
                } else {
                    console.log('✅ No active locks');
                }
                
                if (lockStatus.queuedLocks.length > 0) {
                    console.log('\n⏳ Queued Locks:');
                    console.table(lockStatus.queuedLocks);
                } else {
                    console.log('✅ No queued locks');
                }
                
                return lockStatus;
            },
            
            checkComponentLocks: (componentId) => {
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return null;
                }
                
                if (!componentId) {
                    console.log('💡 Usage: debugTools.checkComponentLocks("element_123")');
                    console.log('💡 Or use "global" for global locks');
                    return null;
                }
                
                const componentLocks = eventHandler.getComponentLocks(componentId);
                
                console.log(`🔒 Locks for Component: ${componentId}`);
                
                if (componentLocks.active.length > 0) {
                    console.log('\n🟢 Active Locks:');
                    console.table(componentLocks.active);
                } else {
                    console.log('✅ No active locks for this component');
                }
                
                if (componentLocks.queued.length > 0) {
                    console.log('\n⏳ Queued Locks:');
                    console.table(componentLocks.queued);
                } else {
                    console.log('✅ No queued locks for this component');
                }
                
                return componentLocks;
            },
            
            testLockConflict: (lockType, operationId) => {
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return null;
                }
                
                if (!lockType || !operationId) {
                    console.log('💡 Usage: debugTools.testLockConflict("move_operation", "element_123")');
                    console.log('💡 Lock types: move_operation, resize_operation, select_operation, modal_lock, global_lock');
                    return null;
                }
                
                const conflictCheck = eventHandler.checkPotentialConflicts(lockType, operationId);
                
                console.log(`🔍 Testing Lock: ${lockType}_${operationId}`);
                
                if (conflictCheck.canAcquire) {
                    console.log('✅ Lock can be acquired - no conflicts');
                } else {
                    console.log('❌ Lock would conflict with:');
                    console.table(conflictCheck.conflicts);
                }
                
                return conflictCheck;
            },
            
            releaseLock: (lockType, operationId) => {
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return false;
                }
                
                if (!lockType || !operationId) {
                    console.log('💡 Usage: debugTools.releaseLock("move_operation", "element_123")');
                    return false;
                }
                
                try {
                    eventHandler.releaseLock(lockType, operationId, 'manual_debug_release');
                    console.log(`✅ Released lock: ${lockType}_${operationId}`);
                    return true;
                } catch (error) {
                    console.error(`❌ Failed to release lock: ${error.message}`);
                    return false;
                }
            },
            
            emergencyUnlock: () => {
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return false;
                }
                
                const lockStatus = eventHandler.getLockStatus();
                const activeLockCount = Object.keys(lockStatus.active_locks).length;
                
                if (activeLockCount === 0) {
                    console.log('✅ No locks to release');
                    return true;
                }
                
                console.log(`🚨 Emergency release of ${activeLockCount} active locks`);
                eventHandler.releaseAllLocks('emergency_debug_unlock');
                console.log('✅ All locks released');
                return true;
            },
            
            // Check for problematic CSS properties that could interfere with interactions
            checkInteractionState: (containerId) => {
                if (!containerId) {
                    console.log('💡 Usage: debugTools.checkInteractionState("element_123")');
                    console.log('💡 Or use debugTools.selectContainer() then call this method');
                    return null;
                }
                
                const element = document.getElementById(containerId);
                if (!element) {
                    console.error(`❌ Element not found: ${containerId}`);
                    return null;
                }
                
                const computedStyle = window.getComputedStyle(element);
                const interactionState = {
                    elementId: containerId,
                    // Critical interaction properties
                    pointerEvents: computedStyle.pointerEvents,
                    userSelect: computedStyle.userSelect,
                    cursor: computedStyle.cursor,
                    
                    // Display and positioning
                    display: computedStyle.display,
                    visibility: computedStyle.visibility,
                    opacity: computedStyle.opacity,
                    position: computedStyle.position,
                    zIndex: computedStyle.zIndex,
                    
                    // Movement/selection related classes
                    classes: Array.from(element.classList),
                    
                    // Data attributes that could indicate state
                    movementState: element.getAttribute('data-movement-state'),
                    selectionState: element.getAttribute('data-selection-state'),
                    ariaSelected: element.getAttribute('aria-selected'),
                    
                    // Check for problematic combinations
                    issues: []
                };
                
                // Identify potential issues
                if (interactionState.pointerEvents === 'none') {
                    interactionState.issues.push('⚠️  pointer-events: none - Element cannot receive mouse events');
                }
                
                if (interactionState.userSelect === 'none' && !interactionState.classes.includes('moving')) {
                    interactionState.issues.push('⚠️  user-select: none without active movement - May block interactions');
                }
                
                if (interactionState.classes.includes('movement-ready') && interactionState.selectionState === 'selected') {
                    interactionState.issues.push('❌ Conflicting state: movement-ready + selected');
                }
                
                if (interactionState.visibility === 'hidden' || interactionState.display === 'none') {
                    interactionState.issues.push('❌ Element is not visible');
                }
                
                if (parseFloat(interactionState.opacity) < 0.1) {
                    interactionState.issues.push('⚠️  Very low opacity - may be hard to interact with');
                }
                
                console.log(`🔍 Interaction State: ${containerId}`);
                
                if (interactionState.issues.length > 0) {
                    console.log('❌ Issues Found:');
                    interactionState.issues.forEach(issue => console.log(`  ${issue}`));
                } else {
                    console.log('✅ No interaction issues detected');
                }
                
                console.log('\n📊 Full State:');
                console.table(interactionState);
                
                return interactionState;
            },
            
            // Fix common interaction issues
            fixInteractionState: (containerId) => {
                if (!containerId) {
                    console.log('💡 Usage: debugTools.fixInteractionState("element_123")');
                    return false;
                }
                
                const element = document.getElementById(containerId);
                if (!element) {
                    console.error(`❌ Element not found: ${containerId}`);
                    return false;
                }
                
                console.log(`🔧 Fixing interaction state for: ${containerId}`);
                
                // Reset problematic CSS properties
                element.style.pointerEvents = 'auto';
                element.style.userSelect = 'auto';
                element.style.cursor = 'default';
                
                // Clean up conflicting classes
                element.classList.remove('movement-ready', 'movement-idle');
                
                // Reset movement state
                element.removeAttribute('data-movement-state');
                element.removeAttribute('data-movement-start');
                
                console.log('✅ Interaction state fixed');
                return true;
            },
            
            // Test lock system manually
            testMovementLock: (containerId) => {
                if (!containerId) {
                    console.log('💡 Usage: debugTools.testMovementLock("element_123")');
                    return false;
                }
                
                const eventHandler = window.toolsApp?.eventHandler;
                if (!eventHandler) {
                    console.error('❌ Event Handler not found');
                    return false;
                }
                
                console.log(`🧪 Testing movement lock for: ${containerId}`);
                
                // Request a test lock
                eventHandler.requestLock('move_operation', containerId, {
                    priority: 'high',
                    context: 'debug_test',
                    reason: 'manual_test'
                }).then(result => {
                    if (result.success) {
                        console.log(`✅ Lock acquired successfully for ${containerId}`);
                        
                        // Test conflict detection
                        console.log('🔍 Testing conflict detection...');
                        debugTools.testLockConflict('move_operation', containerId);
                        
                        // Release after 5 seconds
                        setTimeout(() => {
                            eventHandler.releaseLock('move_operation', containerId, 'debug_test_complete');
                            console.log(`🔓 Test lock released for ${containerId}`);
                        }, 5000);
                    } else {
                        console.error(`❌ Lock denied: ${result.reason}`);
                    }
                }).catch(error => {
                    console.error(`❌ Lock request failed:`, error);
                });
                
                return true;
            },
            
            testDrag: (toolId) => {
                const behavior = window.toolsApp?.dragAndDropBehavior;
                const tool = window.toolsApp?.toolsContainer?.getTool(toolId);
                if (behavior && tool) {
                    console.log('🧪 Testing drag for tool:', toolId);
                    return behavior.startDrag({
                        target: { id: toolId },
                        position: { x: 100, y: 100 },
                        event: null
                    });
                }
                return 'Tool or behavior not found';
            },
            clearCache: () => {
                localStorage.removeItem('panel-state');
                console.log('✅ Panel state cache cleared');
                return 'Cache cleared successfully';
            },

            // Debug tool to check resize handles alignment
            debugResizeHandles: function(componentId) {
                const element = document.getElementById(componentId);
                if (!element) {
                    console.log('❌ Element not found:', componentId);
                    return;
                }
                
                const handlesContainer = element.querySelector('.resize-handles-container');
                if (!handlesContainer) {
                    console.log('❌ Resize handles container not found for:', componentId);
                    return;
                }
                
                const elementRect = element.getBoundingClientRect();
                const elementStyle = window.getComputedStyle(element);
                const handlesRect = handlesContainer.getBoundingClientRect();
                const handlesStyle = window.getComputedStyle(handlesContainer);
                
                console.log('🎯 Resize Handles Debug:', {
                    componentId,
                    element: {
                        position: elementStyle.position,
                        left: elementStyle.left,
                        top: elementStyle.top,
                        width: elementStyle.width,
                        height: elementStyle.height,
                        boundingRect: elementRect
                    },
                    handlesContainer: {
                        position: handlesStyle.position,
                        left: handlesStyle.left,
                        top: handlesStyle.top,
                        right: handlesStyle.right,
                        bottom: handlesStyle.bottom,
                        inset: handlesStyle.inset,
                        width: handlesStyle.width,
                        height: handlesStyle.height,
                        boundingRect: handlesRect
                    },
                    alignment: {
                        leftDiff: handlesRect.left - (elementRect.left - 20),
                        topDiff: handlesRect.top - (elementRect.top - 20),
                        widthDiff: handlesRect.width - (elementRect.width + 40),
                        heightDiff: handlesRect.height - (elementRect.height + 40)
                    },
                    parent: {
                        element: handlesContainer.parentElement?.id,
                        offsetParent: handlesContainer.offsetParent?.id || 'null'
                    }
                });
                
                return {
                    element: elementRect,
                    handles: handlesRect,
                    isAligned: Math.abs(handlesRect.left - (elementRect.left - 20)) < 1 && 
                              Math.abs(handlesRect.top - (elementRect.top - 20)) < 1
                };
            },

            // Debug tool to fix resize handles alignment
            fixResizeHandles: function(componentId) {
                const element = document.getElementById(componentId);
                if (!element) {
                    console.log('❌ Element not found:', componentId);
                    return;
                }
                
                const handlesContainer = element.querySelector('.resize-handles-container');
                if (!handlesContainer) {
                    console.log('❌ Resize handles container not found for:', componentId);
                    return;
                }
                
                // Force proper positioning
                element.style.position = 'absolute';
                handlesContainer.style.cssText = `
                    position: absolute;
                    top: -20px;
                    left: -20px;
                    right: -20px;
                    bottom: -20px;
                    pointer-events: auto;
                    z-index: 1000;
                    display: block;
                `;
                
                console.log('✅ Fixed resize handles positioning for:', componentId);
                return this.debugResizeHandles(componentId);
            },

            // Debug tool to track what happens during resize
            trackResize: function(componentId) {
                const element = document.getElementById(componentId);
                if (!element) {
                    console.log('❌ Element not found:', componentId);
                    return;
                }
                
                // Store original values
                const originalStyles = {
                    width: element.style.width,
                    height: element.style.height,
                    left: element.style.left,
                    top: element.style.top
                };
                
                console.log('🔍 Tracking resize for:', componentId);
                console.log('📏 Original styles:', originalStyles);
                
                // Create observer
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                            const newStyles = {
                                width: element.style.width,
                                height: element.style.height,
                                left: element.style.left,
                                top: element.style.top
                            };
                            console.log('📐 Style change detected:', {
                                old: originalStyles,
                                new: newStyles,
                                element: element.id,
                                timestamp: Date.now()
                            });
                        }
                    });
                });
                
                observer.observe(element, {
                    attributes: true,
                    attributeFilter: ['style']
                });
                
                // Stop tracking after 10 seconds
                setTimeout(() => {
                    observer.disconnect();
                    console.log('🛑 Resize tracking stopped for:', componentId);
                }, 10000);
                
                return observer;
            },

            // Debug tool to check what's being resized
            checkResizeTarget: function() {
                const canvasArea = document.getElementById('canvas-area');
                const containers = document.querySelectorAll('[data-component-type="BaseUserContainer"]');
                
                console.log('🎯 Resize Target Analysis:');
                console.log('Canvas area:', {
                    id: canvasArea?.id,
                    width: canvasArea?.style.width,
                    height: canvasArea?.style.height,
                    hasResizeHandles: !!canvasArea?.querySelector('.resize-handles-container')
                });
                
                console.log('User containers:', Array.from(containers).map(container => ({
                    id: container.id,
                    width: container.style.width,
                    height: container.style.height,
                    hasResizeHandles: !!container.querySelector('.resize-handles-container'),
                    isSelected: container.getAttribute('aria-selected') === 'true'
                })));
                
                return { canvasArea, containers: Array.from(containers) };
            },

            // Debug tool to clean up improper resize handles
            cleanupResizeHandles: function() {
                // Remove resize handles from canvas and other inappropriate elements
                const inappropriateElements = [
                    'canvas-area',
                    'tools-container', 
                    'app-root'
                ];
                
                let cleaned = 0;
                inappropriateElements.forEach(elementId => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        const handlesContainer = element.querySelector('.resize-handles-container');
                        if (handlesContainer) {
                            handlesContainer.remove();
                            cleaned++;
                            console.log(`✅ Removed resize handles from: ${elementId}`);
                        }
                    }
                });
                
                // Also remove any handles from elements without data-component-type="BaseUserContainer"
                const allHandlesContainers = document.querySelectorAll('.resize-handles-container');
                allHandlesContainers.forEach(handlesContainer => {
                    const parent = handlesContainer.parentElement;
                    if (parent && parent.getAttribute('data-component-type') !== 'BaseUserContainer') {
                        handlesContainer.remove();
                        cleaned++;
                        console.log(`✅ Removed resize handles from inappropriate element: ${parent.id || parent.tagName}`);
                    }
                });
                
                console.log(`🧹 Cleanup complete. Removed ${cleaned} inappropriate resize handle containers.`);
                return cleaned;
            },

            // Debug tool to analyze all containers and their states
            analyzeContainers: function() {
                console.log('🔍 === CONTAINER ANALYSIS ===');
                
                // Get all BaseUserContainers
                const containers = document.querySelectorAll('[data-component-type="BaseUserContainer"]');
                const canvasArea = document.getElementById('canvas-area');
                
                console.log(`📊 Found ${containers.length} BaseUserContainer(s) and 1 canvas area`);
                
                // Analyze canvas area
                console.log('\n🎨 CANVAS AREA:');
                console.log({
                    id: canvasArea?.id,
                    tagName: canvasArea?.tagName,
                    position: canvasArea?.style.position,
                    dimensions: {
                        width: canvasArea?.style.width || canvasArea?.offsetWidth + 'px',
                        height: canvasArea?.style.height || canvasArea?.offsetHeight + 'px',
                        left: canvasArea?.style.left,
                        top: canvasArea?.style.top
                    },
                    hasResizeHandles: !!canvasArea?.querySelector('.resize-handles-container'),
                    computedStyles: canvasArea ? {
                        width: getComputedStyle(canvasArea).width,
                        height: getComputedStyle(canvasArea).height,
                        position: getComputedStyle(canvasArea).position
                    } : null
                });
                
                // Analyze each container
                console.log('\n📦 USER CONTAINERS:');
                containers.forEach((container, index) => {
                    const rect = container.getBoundingClientRect();
                    const computedStyle = getComputedStyle(container);
                    
                    console.log(`Container ${index + 1}:`, {
                        id: container.id,
                        selected: container.getAttribute('aria-selected') === 'true',
                        position: container.style.position,
                        inlineDimensions: {
                            width: container.style.width,
                            height: container.style.height,
                            left: container.style.left,
                            top: container.style.top
                        },
                        computedDimensions: {
                            width: computedStyle.width,
                            height: computedStyle.height,
                            left: computedStyle.left,
                            top: computedStyle.top
                        },
                        boundingRect: {
                            width: rect.width,
                            height: rect.height,
                            left: rect.left,
                            top: rect.top
                        },
                        hasResizeHandles: !!container.querySelector('.resize-handles-container'),
                        resizeHandlesVisible: container.classList.contains('resize-handles-visible'),
                        globalRegistry: window.containerRegistry ? !!window.containerRegistry[container.id] : false
                    });
                });
                
                // Check for resize operations in progress
                console.log('\n🔄 RESIZE STATE:');
                const resizingElements = document.querySelectorAll('[data-resize-state="active"]');
                console.log(`Elements currently resizing: ${resizingElements.length}`);
                resizingElements.forEach(el => {
                    console.log(`- ${el.id} (${el.tagName})`);
                });
                
                return {
                    canvasArea,
                    containers: Array.from(containers),
                    resizingElements: Array.from(resizingElements)
                };
            },

            // Debug tool to test resize on specific container
            testContainerResize: function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.log(`❌ Container not found: ${containerId}`);
                    return false;
                }
                
                console.log(`🧪 Testing resize for container: ${containerId}`);
                
                // Get initial state
                const initialState = {
                    inlineWidth: container.style.width,
                    inlineHeight: container.style.height,
                    computedWidth: getComputedStyle(container).width,
                    computedHeight: getComputedStyle(container).height,
                    boundingWidth: container.getBoundingClientRect().width,
                    boundingHeight: container.getBoundingClientRect().height
                };
                
                console.log('📏 Initial state:', initialState);
                
                // Try direct style change
                console.log('🔧 Applying test resize...');
                container.style.width = '300px';
                container.style.height = '150px';
                
                // Force a reflow to ensure styles are applied
                container.offsetHeight;
                
                // Check if change took effect immediately
                const newState = {
                    inlineWidth: container.style.width,
                    inlineHeight: container.style.height,
                    computedWidth: getComputedStyle(container).width,
                    computedHeight: getComputedStyle(container).height,
                    boundingWidth: container.getBoundingClientRect().width,
                    boundingHeight: container.getBoundingClientRect().height
                };
                
                console.log('📐 New state:', newState);
                
                const changed = newState.boundingWidth !== initialState.boundingWidth || 
                               newState.boundingHeight !== initialState.boundingHeight;
                
                console.log(`${changed ? '✅' : '❌'} Visual resize ${changed ? 'successful' : 'failed'}`);
                
                // Add visual inspection markers
                console.log('🔍 VISUAL INSPECTION MARKERS:');
                console.log('Copy and paste this into console to highlight the container:');
                console.log(`document.getElementById('${containerId}').style.border = '5px solid red';`);
                console.log(`document.getElementById('${containerId}').style.backgroundColor = 'yellow';`);
                console.log('Look at the container now - has it visually changed size?');
                
                // Check for CSS overrides
                const computedStyle = getComputedStyle(container);
                console.log('🎨 CSS Analysis:', {
                    position: computedStyle.position,
                    display: computedStyle.display,
                    boxSizing: computedStyle.boxSizing,
                    minWidth: computedStyle.minWidth,
                    minHeight: computedStyle.minHeight,
                    maxWidth: computedStyle.maxWidth,
                    maxHeight: computedStyle.maxHeight,
                    overflow: computedStyle.overflow,
                    transform: computedStyle.transform,
                    zIndex: computedStyle.zIndex
                });
                
                // Wait a moment then revert changes
                setTimeout(() => {
                    container.style.width = initialState.inlineWidth;
                    container.style.height = initialState.inlineHeight;
                    container.style.border = '';
                    container.style.backgroundColor = '';
                    console.log('🔄 Reverted test changes');
                }, 5000);
                
                return changed;
            },

            // Debug tool to trace resize operations in real-time
            traceResizeOperations: function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.log(`❌ Container not found: ${containerId}`);
                    return;
                }
                
                console.log(`🕵️ Starting resize operation tracing for: ${containerId}`);
                
                // Override the container's style property setter to log all changes
                const originalStyleSetters = {};
                const styleProperties = ['width', 'height', 'left', 'top'];
                
                styleProperties.forEach(prop => {
                    const descriptor = Object.getOwnPropertyDescriptor(container.style, prop) ||
                                     Object.getOwnPropertyDescriptor(CSSStyleDeclaration.prototype, prop);
                    
                    if (descriptor && descriptor.set) {
                        originalStyleSetters[prop] = descriptor.set;
                        
                        Object.defineProperty(container.style, prop, {
                            set: function(value) {
                                console.log(`🎯 STYLE CHANGE: ${prop} = "${value}" on ${containerId}`);
                                console.log(`   Stack trace:`, new Error().stack);
                                const result = originalStyleSetters[prop].call(this, value);
                                console.log(`   Visual dimensions after change:`, {
                                    boundingRect: container.getBoundingClientRect(),
                                    computedStyle: {
                                        width: getComputedStyle(container).width,
                                        height: getComputedStyle(container).height
                                    }
                                });
                                return result;
                            },
                            get: descriptor.get,
                            enumerable: descriptor.enumerable,
                            configurable: true
                        });
                    }
                });
                
                // Also trace resize handle events
                const resizeHandlesContainer = container.querySelector('.resize-handles-container');
                if (resizeHandlesContainer) {
                    const handles = resizeHandlesContainer.querySelectorAll('.resize-handle');
                    handles.forEach(handle => {
                        handle.addEventListener('mousedown', (e) => {
                            console.log(`🎯 RESIZE HANDLE MOUSEDOWN: ${handle.className} on ${containerId}`);
                            console.log(`   Event target:`, e.target);
                            console.log(`   Container at mousedown:`, {
                                style: {
                                    width: container.style.width,
                                    height: container.style.height
                                },
                                boundingRect: container.getBoundingClientRect()
                            });
                        });
                    });
                }
                
                console.log('🕵️ Resize tracing active. Perform resize operations now.');
                console.log('Call debugTools.stopResizeTracing() to stop tracing.');
                
                // Store cleanup function
                window._resizeTraceCleanup = () => {
                    styleProperties.forEach(prop => {
                        if (originalStyleSetters[prop]) {
                            Object.defineProperty(container.style, prop, {
                                set: originalStyleSetters[prop],
                                get: Object.getOwnPropertyDescriptor(CSSStyleDeclaration.prototype, prop).get,
                                enumerable: true,
                                configurable: true
                            });
                        }
                    });
                    console.log('🛑 Resize tracing stopped and cleanup complete');
                };
                
                return true;
            },

            // Stop resize tracing
            stopResizeTracing: function() {
                if (window._resizeTraceCleanup) {
                    window._resizeTraceCleanup();
                    delete window._resizeTraceCleanup;
                } else {
                    console.log('❌ No active resize tracing to stop');
                }
            },

            // Debug resize handle target detection
            debugResizeHandleTarget: function(componentId) {
                const element = document.getElementById(componentId);
                if (!element) {
                    console.log('❌ Element not found:', componentId);
                    return;
                }
                
                const handlesContainer = element.querySelector('.resize-handles-container');
                if (!handlesContainer) {
                    console.log('❌ Resize handles container not found for:', componentId);
                    return;
                }
                
                const handles = handlesContainer.querySelectorAll('.resize-handle');
                console.log('🔍 Resize Handle Target Debug:', {
                    componentId,
                    element: {
                        id: element.id,
                        tagName: element.tagName,
                        classes: element.className,
                        dataAttributes: element.dataset,
                        parentElement: element.parentElement?.id || 'none'
                    },
                    handlesContainer: {
                        id: handlesContainer.id,
                        parentElement: handlesContainer.parentElement?.id,
                        offsetParent: handlesContainer.offsetParent?.id || 'null'
                    },
                    handles: Array.from(handles).map(h => ({
                        position: h.dataset.resizePosition,
                        classes: h.className,
                        parentContainer: h.closest('.resize-handles-container')?.parentElement?.id
                    })),
                    containerRegistry: window.containerRegistry?.[componentId] ? 'found' : 'not found',
                    canvas: {
                        window_canvas: !!window.canvas,
                        window_formBuilderCanvas: !!window.formBuilderCanvas,
                        canvasContainers: window.canvas?.containers?.length || 0,
                        formBuilderContainers: window.formBuilderCanvas?.containers?.length || 0
                    }
                });
                
                // Test what the resize handle detection logic would find
                handles.forEach(handle => {
                    const position = handle.dataset.resizePosition;
                    console.log(`🎯 Testing detection for ${position} handle:`);
                    
                    // Method 1: Look for resize handles container, then get its parent
                    const handlesContainer = handle.closest('.resize-handles-container');
                    if (handlesContainer && handlesContainer.parentElement) {
                        const container = handlesContainer.parentElement;
                        console.log(`  Method 1: Found container ${container.id} via handles container`);
                    }
                    
                    // Method 2: Look for any parent with an ID
                    let container = handle.closest('[id]');
                    if (container && container.classList.contains('resize-handles-container')) {
                        container = container.parentElement;
                    }
                    console.log(`  Method 2: Found container ${container?.id || 'none'} via closest ID`);
                    
                    // Method 3: Look for container with specific patterns
                    container = handle.closest('[id*="element_"], .base-user-container, [data-container-type]');
                    console.log(`  Method 3: Found container ${container?.id || 'none'} via pattern matching`);
                });
                
                return { element, handlesContainer, handles: handles.length };
            }
        };

        // ========================
        // TEMPORARY DRAG EVENT LISTENERS (Proof of Concept)
        // ========================
        
        // Add drag event listeners after initialization
        document.addEventListener('dragstart', (event) => {
            const toolElement = event.target.closest('.tool-item');
            if (toolElement && window.toolsApp?.dragAndDropBehavior) {
                const toolId = toolElement.id?.replace('tool-', '') || 'unknown';
                console.log('🎯 HTML5 Drag started for tool:', toolId);
                
                // Store drag data
                event.dataTransfer.setData('text/plain', toolId);
                event.dataTransfer.effectAllowed = 'copy';
                
                // Trigger DragAndDropBehavior
                try {
                    const result = window.toolsApp.dragAndDropBehavior.startDrag({
                        target: { id: toolId, type: toolId },
                        position: { x: event.clientX, y: event.clientY },
                        event: event
                    });
                    console.log('🎯 DragAndDropBehavior.startDrag result:', result);
                } catch (error) {
                    console.error('❌ Error in startDrag:', error);
                }
            }
        });
        
        document.addEventListener('dragover', (event) => {
            // Prevent default to allow drop
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
        });
        
        document.addEventListener('drop', (event) => {
            event.preventDefault();
            
            const dropZone = event.target.closest('.canvas-area');
            if (dropZone && window.toolsApp?.dragAndDropBehavior) {
                const toolId = event.dataTransfer.getData('text/plain');
                console.log('🎯 HTML5 Drop detected - tool:', toolId);
                
                // Calculate drop position
                const rect = dropZone.getBoundingClientRect();
                const dropPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                // Trigger DragAndDropBehavior
                try {
                    const result = window.toolsApp.dragAndDropBehavior.completeDrop({
                        target: { id: 'canvas-area' },
                        position: dropPosition,
                        event: event
                    });
                    console.log('🎯 DragAndDropBehavior.completeDrop result:', result);
                } catch (error) {
                    console.error('❌ Error in completeDrop:', error);
                }
            }
        });

        console.log('🎨 Reactive ToolsContainer loaded. Architecture compliant!');
        console.log('🔧 Try debugTools.getGraphicsHandler() in console!');
    </script>
</body>
</html>